import { defineEventHandler, readBody, createError } from 'h3';
import { generateImage } from '~/server/services/geminiImageService';
import type { GenerateImageOptions, GenerateImageResult, GeminiImageModelType } from '~/types/gemini';
import fs from 'node:fs/promises';
import path from 'node:path';

export default defineEventHandler(async (event) => {
  try {
    const options = await readBody<Partial<GenerateImageOptions>>(event);
    const config = useRuntimeConfig();

    const modelToUse = options.model || config.geminiImageModel as GeminiImageModelType | undefined;

    if (!options.prompt) {
      throw createError({
        statusCode: 400,
        statusMessage: 'Bad Request',
        message: 'Missing required parameter: prompt must be provided.',
      });
    }

    if (!modelToUse) {
      throw createError({
        statusCode: 400,
        statusMessage: 'Bad Request',
        message: 'Missing required parameter: model must be provided in the request or configured as a default in .env (GEMINI_IMAGE_MODEL).',
      });
    }

    const fullOptions: GenerateImageOptions = {
      ...options, // Spread other options like numberOfImages, aspectRatio
      prompt: options.prompt,
      model: modelToUse, // Guaranteed to be a string here
    };

    const result: GenerateImageResult = await generateImage(fullOptions);

    // Check if images were generated and extract the first one
    if (result.images && result.images.length > 0) {
      // Assuming we only care about the first image for this endpoint's purpose

      console.log("[/api/ai/image/generate.post.ts] Image successfully generated by service. Saving image and returning URL.");

      const image = result.images[0];
      const fileExtension = image.mimeType.split('/')[1]; // e.g., 'png', 'jpeg'
      const filename = `generated-image-${Date.now()}.${fileExtension}`;
      const publicDir = path.join(process.cwd(), 'public', 'generated-images');
      const filePath = path.join(publicDir, filename);

      // Ensure the directory exists
      await fs.mkdir(publicDir, { recursive: true });

      // Save the image data (assuming imageData is a Buffer or can be written directly)
      // If imageData is base64, you might need to convert it first:
      // const base64Data = image.imageData.replace(/^data:image\/\w+;base64,/, '');
      // const buffer = Buffer.from(base64Data, 'base64');
      // await fs.writeFile(filePath, buffer);
      await fs.writeFile(filePath, image.imageData);


      const imageUrl = `/generated-images/${filename}`;

      return {
        imageUrl: imageUrl,
        text: result.text, // Optionally include any accompanying text
      };
    } else {
      // No images were generated, or the images array was empty
      // Log the text part if it exists, as it might contain an explanation from the API
      console.error("[/api/ai/image/generate.post.ts] No images generated by service. Text from service (if any):", result.text);
      // Return an error or a specific structure indicating no image
      // Throwing an error that will be caught by the generic error handler below might be cleaner
      throw createError({
        statusCode: 404, // Or 500 if it implies an internal failure to generate
        statusMessage: "Image Generation Failed",
        message: result.text || "The image generation service did not return any images.",
      });
    }

  } catch (error: any) {
    console.error('[API Error] /ai/image/generate:', error.message, error.data || error.stack);
    // If it's an error we threw with createError, rethrow it or return its structure
    if (error.statusCode) {
      event.node.res.statusCode = error.statusCode;
      return { error: { statusCode: error.statusCode, message: error.message, statusMessage: error.statusMessage } };
    }
    // For other unexpected errors from the service or elsewhere
    event.node.res.statusCode = 500;
    return { error: { statusCode: 500, message: error.message || 'An unexpected error occurred during image generation.' } };
  }
});
